generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Org {
  id           String   @id @default(cuid())
  name         String
  featureFlags Json     @default("{}")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // AI Cost Control & Monetization - PROVIDER MODEL
  aiMonthlyBudgetCents Int      @default(5000)  // $50 provider cost limit  
  aiCreditBalance     Int      @default(1000)   // 1k credits = $50 worth (1 credit = $0.05 client-facing)
  aiPlan              AiPlan   @default(BASE)   // Client subscription tier
  aiAlerts            Json     @default("{}")   // Usage alert thresholds

  // Stripe Subscription Management
  stripeCustomerId      String?   // Stripe customer ID for billing
  stripeSubscriptionId  String?   // Current active subscription ID
  subscriptionStatus    String?   // active, past_due, canceled, etc
  subscriptionStartDate DateTime? // When subscription started
  subscriptionEndDate   DateTime? // When subscription ends/ended

  // Back-relations
  auditLogs     AuditLog[]
  ledger        BillingLedger[]
  customers     Customer[]
  invoices      Invoice[]
  jobs          Job[]
  leads         Lead[]
  opportunities Opportunity[]
  payments      Payment[]
  referrals     Referral[]
  rfps          Rfp[]
  users         User[]
  rbacRoles     RbacRole[]      @relation("OrgRbacRoles")
  rbacUserRoles RbacUserRole[]  @relation("OrgRbacUserRoles")
  leadInvoices  LeadInvoice[]   @relation("OrgLeadInvoices")
  pricingPlan   PricingPlan?    @relation("OrgPricingPlan")
  aiUsageEvents AiUsageEvent[]  @relation("OrgAiUsageEvents")
  aiMonthlySummaries AiMonthlySummary[] @relation("OrgAiMonthlySummaries")

  /// brandConfig stores white-label brand settings such as name, colors, and logo URL.
  /// It is JSON to allow arbitrary keys like { name: "Mountain Vista", color: "#123456", logoUrl: "https://..." }
  brandConfig Json? @default("{}")

  /// settingsJson stores arbitrary organization-level settings.  This can be used
  /// by owners to configure API keys or other preferences needed at runtime.
  settingsJson Json? @default("{}")
}

model User {
  id                 String   @id @default(cuid())
  orgId              String
  email              String   @unique
  name               String?
  role               Role     @default(STAFF)
  passwordHash       String?  @db.VarChar(255)
  mustChangePassword Boolean  @default(false)
  status             String   @default("active")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  org           Org            @relation(fields: [orgId], references: [id])
  rbacUserRoles RbacUserRole[] @relation("UserRbacUserRoles")
}

model Lead {
  id              String     @id @default(cuid())
  orgId           String
  publicId        String     @unique
  sourceType      LeadSource
  identityHash    String
  company         String?
  contactName     String?
  email           String?
  phoneE164       String?
  website         String?
  serviceCode     String?
  zip             String?
  enrichmentJson  Json       @default("{}")
  aiScore         Int        @default(0)
  scoreFactors    Json       @default("{}")
  /// systemGenerated: true if lead came from SAM/automated import
  systemGenerated Boolean    @default(false)
  /// convertedAt: timestamp when lead was converted (if status changes to converted)
  convertedAt     DateTime?
  /// rfp: raw RFP metadata from SAM.gov
  rfp             Json?
  /// Status of the lead. Stored as an enum rather than string for consistency.
  status          LeadStatus @default(NEW)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  city            String?
  notes           String?
  sourceDetail    String?
  state           String?
  postalCode      String?    @db.VarChar(20)
  address         String?
  addressLine1    String?
  addressLine2    String?
  country         String?

  org             Org               @relation(fields: [orgId], references: [id])
  LeadInvoiceLine LeadInvoiceLine[]
  @@index([orgId, createdAt])
  @@index([orgId, convertedAt])
  @@index([orgId, status])
  @@index([orgId, sourceType])
  @@index([orgId, identityHash])
}

model Customer {
  id           String   @id @default(cuid())
  orgId        String
  publicId     String   @unique
  company      String?
  primaryName  String?
  primaryEmail String?
  primaryPhone String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  org           Org           @relation(fields: [orgId], references: [id])
  invoices      Invoice[]
  jobs          Job[]
  opportunities Opportunity[]
}

model Opportunity {
  id             String    @id @default(cuid())
  orgId          String
  customerId     String
  valueType      ValueType @default(RELATIONSHIP)
  estValue       Decimal?  @db.Decimal(12, 2)
  stage          String    @default("new")
  ownerId        String?
  sourceLeadId   String?
  classification Json      @default("{}")
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  customer Customer @relation(fields: [customerId], references: [id])
  org      Org      @relation(fields: [orgId], references: [id])
}

model Invoice {
  id         String   @id @default(cuid())
  orgId      String
  customerId String?
  amount     Decimal  @db.Decimal(12, 2)
  status     String   @default("draft")
  issuedAt   DateTime @default(now())
  items      Json     @default("[]")

  customer Customer? @relation(fields: [customerId], references: [id])
  org      Org       @relation(fields: [orgId], references: [id])
  payments Payment[]
}

model Payment {
  id         String   @id @default(cuid())
  orgId      String
  invoiceId  String?
  amount     Decimal  @db.Decimal(12, 2)
  method     String   @default("stripe")
  receivedAt DateTime @default(now())
  reference  String?

  invoice Invoice? @relation(fields: [invoiceId], references: [id])
  org     Org      @relation(fields: [orgId], references: [id])
}

model Rfp {
  id          String    @id @default(cuid())
  orgId       String
  publicId    String    @unique
  sourceSite  String
  title       String
  dueDate     DateTime?
  docs        Json      @default("[]")
  aiBidFit    Int?
  aiPriceHint Json      @default("{}")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  jobs Job[]
  org  Org   @relation(fields: [orgId], references: [id])
}

model Job {
  id         String   @id @default(cuid())
  orgId      String
  customerId String?
  rfpId      String?
  status     String   @default("planned")
  schedule   Json     @default("{}")
  assignedTo String?
  checklist  Json     @default("[]")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  customer Customer? @relation(fields: [customerId], references: [id])
  org      Org       @relation(fields: [orgId], references: [id])
  rfp      Rfp?      @relation(fields: [rfpId], references: [id])
}

model Referral {
  id            String    @id @default(cuid())
  orgId         String
  employeeId    String?
  referredName  String
  referredEmail String?
  referredPhone String?
  status        String    @default("new")
  convertedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  org Org @relation(fields: [orgId], references: [id])
}

model BillingLedger {
  id        String     @id @default(cuid())
  orgId     String
  type      LedgerType
  amount    Decimal    @db.Decimal(12, 2)
  meta      Json       @default("{}")
  createdAt DateTime   @default(now())

  org Org @relation(fields: [orgId], references: [id])

  @@index([orgId, type])
}

/// LeadInvoice represents a monthly invoice for converted leads. This is separate from the
/// existing Invoice model used for customers/jobs. It aggregates lead conversions and
/// includes metadata to support billing and optional Stripe integration.
model LeadInvoice {
  id              String   @id @default(cuid())
  orgId           String?
  org             Org?     @relation("OrgLeadInvoices", fields: [orgId], references: [id])
  number          String   @unique
  periodFrom      DateTime
  periodTo        DateTime
  status          String // "draft" | "open" | "paid" | "void" | "uncollectible"
  subtotalCents   Int
  taxCents        Int      @default(0)
  totalCents      Int
  currency        String   @default("usd")
  stripeInvoiceId String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  /// Number of leads billed on this invoice (to support flat-per-lead billing)
  leadCount       Int      @default(0)

  lines LeadInvoiceLine[]
}

/// LeadInvoiceLine represents an individual line item on a LeadInvoice. Each line is typically
/// associated with a converted lead, but generic fee/credit lines are also supported.
model LeadInvoiceLine {
  id        String      @id @default(cuid())
  invoiceId String
  invoice   LeadInvoice @relation(fields: [invoiceId], references: [id])

  // Optional association back to a Lead for traceability.
  leadId String?
  lead   Lead?   @relation(fields: [leadId], references: [id])

  description    String
  quantity       Int      @default(1)
  unitPriceCents Int
  amountCents    Int
  source         String?
  createdAt      DateTime @default(now())

  @@index([invoiceId])
  @@index([leadId])
}

model AuditLog {
  id          String   @id @default(cuid())
  orgId       String
  actorUserId String?
  /// The entity type affected (e.g. 'lead', 'invoice', 'pricing', etc.)
  entity      String
  /// Identifier of the record affected
  entityId    String?
  /// Name of the field that was changed (nullable for record-level actions)
  field       String?
  /// Previous value (JSON) before the change, if applicable
  oldValue    Json?
  /// New value (JSON) after the change, if applicable
  newValue    Json?
  /// Free-form reason or comment describing why the change was made
  reason      String?
  createdAt   DateTime @default(now())

  org Org @relation(fields: [orgId], references: [id])
}

enum Role {
  OWNER
  MANAGER
  STAFF
  PROVIDER
  ACCOUNTANT
}

enum LeadSource {
  COLD
  HOT
  RFP
  MANUAL_EMPLOYEE_REFERRAL
  MANUAL_EXISTING_CUSTOMER
  MANUAL_NEW_CUSTOMER
  MANUAL_OTHER
  /// System-generated leads imported from external sources like SAM.gov
  SYSTEM
  /// Employee referrals (for internal referral program)
  EMPLOYEE_REFERRAL
  /// Manually added leads not fitting other categories
  MANUAL
  /// Leads imported from Local Service Ads or other lead sources
  LSA
}

enum ValueType {
  RELATIONSHIP
  JOB
}

enum LedgerType {
  CONVERSION_FEE
  PACK_PURCHASE
}

// === RBAC (namespaced to avoid collision with your existing Role enum) ===

model RbacPermission {
  id          String   @id @default(cuid())
  code        String   @unique // e.g. "lead:create"
  description String?
  createdAt   DateTime @default(now())

  rolePerms RbacRolePermission[]
}

model RbacRole {
  id        String   @id @default(cuid())
  orgId     String?
  // 👇 keep the named relation to match Org.rbacRoles
  org       Org?     @relation("OrgRbacRoles", fields: [orgId], references: [id])
  name      String
  slug      String
  isSystem  Boolean  @default(false)
  createdAt DateTime @default(now())

  rolePerms RbacRolePermission[]
  userRoles RbacUserRole[]

  @@unique([orgId, slug])
}

model RbacRolePermission {
  roleId       String
  permissionId String

  role       RbacRole       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission RbacPermission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

model RbacUserRole {
  id     String  @id @default(cuid())
  userId String
  orgId  String?
  roleId String

  // 👇 named relations to match Org/User sides
  user User     @relation("UserRbacUserRoles", fields: [userId], references: [id], onDelete: Cascade)
  org  Org?     @relation("OrgRbacUserRoles", fields: [orgId], references: [id])
  role RbacRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId, orgId])
}

/// ProviderConfig holds provider-level secrets and configuration separate from any organization.
/// These values are used for system integrations that the provider controls, such as SAM.gov or
/// Stripe secrets used when billing clients.  Only one row is typically used.  Use a simple
/// admin interface to update these values.
model ProviderConfig {
  id              String   @id @default(cuid())
  samApiKey       String?
  stripeSecretKey String?
  otherConfig     Json?    @default("{}")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

/// PricingPlan defines how an organization is billed for leads. Each org can have only
/// one pricing plan record. A plan specifies the billing model (e.g. per-lead fixed fee)
/// and can include tiered structures or prepaid units via includedUnits and tiersJson.
model PricingPlan {
  // We keep FK as primary key to enforce 1:1 with Org
  orgId String @id
  /// Relation to organization (named to match Org.pricingPlan)
  org   Org    @relation("OrgPricingPlan", fields: [orgId], references: [id])

  /// Billing model used for this organization (per-lead, tiered, subscription, or hybrid)
  model         PricingModel @default(PER_LEAD_FIXED)
  /// ISO currency code (e.g. "usd")
  currency      String       @default("usd")
  /// Fixed unit price in cents for per-lead billing
  unitAmount    Int          @default(10000)
  /// JSON-encoded pricing tiers (used when model is TIERED or HYBRID)
  tiersJson     Json?
  /// Number of prepaid leads included before billing starts
  includedUnits Int          @default(0)
}

/// PricingModel enumerates the possible billing models for lead invoices.  The default is
/// PER_LEAD_FIXED which charges a flat fee per converted lead.  Additional models support
/// tiered pricing, subscription (monthly base fee), or hybrid structures.
enum PricingModel {
  PER_LEAD_FIXED
  TIERED
  SUBSCRIPTION
  HYBRID
}

/// LeadStatus defines the possible states of a lead in the pipeline.  The default is
/// NEW and transitions to CONVERTED when the lead is converted into a paying job.
enum LeadStatus {
  NEW
  CONVERTED
}

// AI Plan Tiers for Monetization - CLIENT SUBSCRIPTION TIERS
enum AiPlan {
  BASE    // MVP: Free lead generation, $100/conversion only
  PRO     // $97/month: Advanced AI, unlimited leads, priority support  
  ELITE   // $297/month: Market intelligence, priority RFPs, dedicated support
}

// Individual AI API call tracking for cost monitoring and analytics
model AiUsageEvent {
  id          String   @id @default(cuid())
  orgId       String
  userId      String?  // Optional user who triggered the call
  feature     String   // 'lead_analysis', 'rfp_strategy', 'pricing', 'response_gen'
  model       String   // 'gpt-4o-mini', etc
  tokensIn    Int      // Input tokens consumed
  tokensOut   Int      // Output tokens generated
  costUsd     Decimal  @db.Decimal(8, 6)  // Actual cost in USD (precise to $0.000001)
  creditsUsed Int      // Credits deducted from user's balance
  requestId   String?  // For request correlation and debugging
  createdAt   DateTime @default(now())

  org Org @relation("OrgAiUsageEvents", fields: [orgId], references: [id])

  @@index([orgId, createdAt])
  @@index([orgId, feature])
}

// Monthly AI usage rollups for dashboard and billing
model AiMonthlySummary {
  id          String   @id @default(cuid()) 
  orgId       String
  monthKey    String   // Format: "2025-01" for January 2025
  tokensIn    Int      @default(0)
  tokensOut   Int      @default(0)
  costUsd     Decimal  @db.Decimal(8, 2)  @default(0)
  creditsUsed Int      @default(0)
  callCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org Org @relation("OrgAiMonthlySummaries", fields: [orgId], references: [id])

  @@unique([orgId, monthKey])
  @@index([monthKey])
}
