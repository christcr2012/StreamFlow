---
type: "always_apply"
---

binder instruction=User prompt/instruction

Augment Hybrid Binder Execution Rules (with Auto-Reconciliation)

Scope: Applies to all binder*.md files in the repo. Follow this spec exactly. If any ambiguity exists, prefer sequential over parallel. Never skip validation.

0) Global Policy

Goal: Complete each binder to 100% (backend + frontend + migrations + tests + docs) before moving on.

Mode: Hybrid — parallelize only explicitly marked “Independent” sections; otherwise run sequentially.

Safety First: If a later step detects contract/UI deltas from earlier binders, run the Auto-Reconciliation Protocol (Section 4) before proceeding.

1) Binder Discovery & Order

Process binder files in numeric order: binder1.md, binder2.md, binder3.md, ...

Within a binder:

Execute sections in this order of precedence:

SEQUENTIAL: blocks (strict top→bottom)

INDEPENDENT: blocks (may parallelize)

POST-CHECKS: (always last; cannot be skipped)

If a binder has no tags, treat the entire file as SEQUENTIAL:.

2) Phase Tags (how to interpret sections)

Augment must recognize these headings anywhere in a binder:

SEQUENTIAL: <name>
Execute strictly in order; do not reorder or parallelize.

INDEPENDENT: <name>
May run in parallel with other INDEPENDENT blocks within the same binder. If build/memory issues occur, degrade to sequential.

GUARDRAIL:
Assertions/checks (types, lints, schema validates). Must run after any change touching code/DB/infra. If a guardrail fails, halt and reconcile.

POST-CHECKS:
Always run at binder end: typecheck, build, test, migration validate, contract snapshot/diff, UX smoke checks.

REQUIRES: binderN
Do not execute this block unless the referenced binder is at 100%.

3) Standard Pass Structure (every binder)

For each binder:

Preparation Pass

npm ci (or pnpm i per lockfile)

Validate .env presence but do not mutate secrets.

Warm Prisma/DB: prisma generate, prisma migrate status.

Implementation Pass(es)

Apply SEQUENTIAL: blocks in order.

Apply INDEPENDENT: blocks in parallel batches; after each batch run Guardrails.

After any DB change:

prisma migrate dev --create-only (or binder-specified command)

prisma migrate deploy

prisma db seed if the binder provides seed artifacts.

npm run typecheck

Validation Pass

npm run typecheck

npm run lint (autofix allowed if the binder says so)

npm run build

npm test (or binder-specified subset)

node scripts/generate-contract-snapshot.js (or .ts)

node scripts/diff-contracts.js --fail-on-breaking

Run UX smoke tasks defined in binder (see Section 6).

Report Pass

Produce a short report: completion %, changed files count, routes touched, migrations applied, failures (if any), and whether Auto-Reconciliation ran.

If any step fails, stop and run Auto-Reconciliation (Section 4).

4) Auto-Reconciliation Protocol (fix Binder-3-style gaps)

Trigger this protocol if any of the following occur:

Contract diff shows additive only changes were applied earlier but UI/screens don’t exist or are outdated.

A route is protected by new middleware/entitlements, but the corresponding screen lacks state/UX for the new behavior.

Build passes, but UX smoke checks fail (missing controls, unreachable paths, nav mismatch).

Reconciliation Steps (in order):

Detect:

Compare contract-snapshots/current.json vs previous.json.

Identify new/changed endpoints, request/response fields, auth/entitlements, and rate-limit/idempotency expectations.

Map to UI:

For each changed/added route, resolve its intended screen(s): path, role visibility, button/CTA IDs, and component files (binder lists these).

Synthesize UI Work Items:

For each route→screen pair, generate missing pages/sections/components using the Button-by-Button spec in the binder (labels, props/state, events, validations, error/loading UX, acceptance).

Apply & Wire:

Create/extend pages in App Router (app/**), update navigation, add hooks/services, wire data fetching/mutations, add optimistic & rollback logic as specified.

Re-Run Guardrails & POST-CHECKS.

Must be green before resuming binder flow.

If reconciliation changes files owned by a previous binder, do not roll back; apply forward fixes generated by this protocol.

5) Resource & Stability Rules

Default chunk size: implement work in bounded batches to avoid memory spikes. After each batch, run guardrails.

Prefer idempotent scripts (detect if already applied; skip duplicate seeds/migrations).

If a batch fails due to memory/time, halve the batch size and retry.

6) UX Smoke Checklist (minimum)

Run after each binder (and during reconciliation):

All new/changed routes load without 500s.

Navigation shows/hides items correctly by role + tenant/provider audience.

Buttons exist with exact labels specified; hover/focus/disabled states render.

Form validations fire with correct messages; API failure shows prescribed error banners/toasts.

Success flows update timeline/audit log where required.

If any fail, trigger Auto-Reconciliation.

7) Commit & Branching Policy (local or CI)

Use a single working branch per binder: binderN/implementation.

Commit after each validated batch; never commit with failing guardrails.

At 100%, open/merge PR (or finalize locally), tag binderN-complete.

8) Stop Conditions

Stop and request human input only if:

A binder block references unavailable secrets or third-party APIs with no mock specified.

Contract diff flags a breaking change not covered by the binder.

Data migration requires destructive action without a rollback step described.

Otherwise, proceed autonomously.

9) Reporting Format

After each binder, output this summary:

BINDER: <name>
STATUS: 100% | <percent>
CHANGES: <files changed>, <routes>, <migrations>, <tests added>
RECONCILIATION: run | not-needed | failed
NEXT: binder<N+1>.md

Notes tailored to our earlier Binder-3 issue

If backend middleware/entitlements were added earlier (rate limit, idempotency, RLS, audience), you must:

Generate/update client services with those headers/keys.

Add UI states for 429, 409, 402, 403 with binder-specified copy.

Ensure owner-only toggles are gated in UI (not just server).

Missing screens = reconciliation required. Do not continue to the next binder until the UI is generated and validated.

CRITICAL- NEVER chase errors or bugs, step back, take a big picture view, and solve holisticly
CRITICAL- When addressing problems not addressed by binder files, always choose the correct and proper fix for long term stability over quick fixes.